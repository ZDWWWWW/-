# Spring

## Sping的IOC和AOP理解

### IOC(Inversion of Control) 

![image-20200619100250089](框架.assets/image-20200619100250089.png)

IOC 让Spring创建对象 避免程序员手动new对象 是一种设计思想

DI 则实现了组件中完成另一个组件的调用（在ServiceImpl组件中调用DAO组件 ，这里的DAO相当于ServiceImpl的依赖，因为ServiceImpl要使用DAO中方法）



### AOP（Aspect Oriented Programming）

面向切面编程（aop）是对面向对象编程（oop）的补充。在 OOP 中模块化的关键单元是类，而在 AOP 中，模块化单元是切面。所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。

Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务.

#### **AOP的底层机制：动态代理**

静态代理主要通过将真实类与代理类实现同一个接口，让代理类持有真实类对象，然后在代理类方法中调用真实类方法，在调用真实类方法的前后添加我们所需要的功能扩展代码来达到增强的目的，调用时通过·**代理类来创建代理对象**。

**缺点：**一个代理类只能为一个真实类服务，如果需要增强的真实类有很多，则需要编写大量的代理类。

```java
/**
 * 代理类与目标类的共同接口
 */
public interface Subject {
    void request();
    void response();
}
/**
 * 目标类
 */
public class RealSubject implements Subject {

    @Override
    public void request() {
        System.out.println("执行目标对象的request方法......");
    }

    @Override
    public void response() {
        System.out.println("执行目标对象的response方法......");
    }
}
/**
 * 代理类
 */
public class ProxySubject implements Subject {

    private Subject subject;

    public ProxySubject(Subject subject) {
        this.subject = subject;
    }

    @Override
    public void request() {
        System.out.println("before 前置增强");
        subject.request();
        System.out.println("after 后置增强");
    }

    @Override
    public void response() {
        System.out.println("before 前置增强");
        subject.response();
        System.out.println("after 后置增强");
    }
}

public class Main {

    public static void main(String[] args) {
        //目标对象
        Subject realSubject = new RealSubject();
        //代理对象 通过构造器注入目标对象
        Subject proxySubject = new ProxySubject(realSubject);

        proxySubject.request();
        proxySubject.response();
    }
}
```



与静态代理相比，动态代理的**代理类不需要程序员自己手动定义，而是在程序运行时动态生成**

动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理

- 基于接口的动态代理----JDK动态代理
- 基于类的动态代理--CGLib

如果类是实现了某个接口的，则会使用JDK动态代理，生成一个实现同样接口的代理类，直接调用这个代理类。

如果类没有实现接口，则使用CGLib生成类的子类，可以动态生成字节码，覆盖你的一些方法，在方法中增强代码。

Spring AOP中的代理使用的默认策略是：
如果目标对象实现了接口，则默认采用JDK动态代理
如果目标对象没有实现接口，则采用CgLib进行动态代理
如果目标对象实现了接口，且强制CgLib代理，则采用CgLib进行动态代理

##### JDK动态代理

1. 定义一个java.lang.reflect.InvocationHandler接口的实现类MyInvocationHandler，重写invoke方法
2. 将MyInvocationHandler对象作为参数传入java.lang.reflect.Proxy的newProxyInstance方法中
3. 通过调用java.lang.reflect.Proxy的newProxyInstance方法获得动态代理对象
4. 通过代理对象调用目标方法

重点就是两个方法 invoke() 和 newProxyInstance()

```java
Object invoke(Object proxy, Method method, Object[] args) throws Throwable
proxy:　 - 指代我们所代理的那个真实对象
method:　- 指代的是我们所要调用真实对象的某个方法的Method对象
args:　　- 指代的是调用真实对象某个方法时接受的参数
    
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException
loader:　　    一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载
interfaces:　　一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了
h:　　         一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上
```

**下面的Subject接口换到项目上就是 UserService接口**

```java
/**
 * 自定义InvocationHandler的实现类
 */
public class MyInvocationHandler implements InvocationHandler {

    private Subject subject;

    public MyInvocationHandler(Subject subject) {
        this.subject = subject;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        System.out.println("before 前置通知");
        Object result = null;

        try {
            System.out.println("当前执行的方法："+method.getName());
            System.out.println("当前执行的方法的参数："+args[0]);
            System.out.println("开启事务");
            //通过反射机制，调用真实类中方法
            result = method.invoke(subject, args);
            System.out.println("提交事务");
        }catch (Exception ex) {
            System.out.println("ex: " + ex.getMessage());
            System.out.println("回滚事务");
            throw ex;
        }finally {
            System.out.println("after 后置通知");
        }
        return result;
    }
}

public class Main {

    public static void main(String[] args) {

        //获取InvocationHandler对象 在构造方法中注入目标对象
        InvocationHandler handler = new MyInvocationHandler(new RealSubject());
        //获取代理类对象
		Subject proxySubject = (Subject)Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[]{Subject.class}, handler);
        //调用目标方法时，实则调用InvocationHandler中的invoke方法，并将方法名和参数传给invoke
        proxySubject.request();
        proxySubject.response();
    }
}
```



#### 术语

joinPoint:连接点。在spring中只支持方法连接点，连接点指的是可以使用advice(增强)的地方，例如一个类中有5个方法，那么这5个方法，那么这5个方法都可以是连接点。

pointcut:切入点。可理解为实实在在的连接点，即切入advice(增强)的点。例如一个类中有5个方法，其中有3个方法（连接点）需要织入advice(增强)，那么这3个需要织入advice的连接点就是切入点。

advice:增强/通知。实际中想要添加的功能，如日志、权限校验。

aspect:切面。拦截器类，其中会定义切点以及通知。

#### 使用

创建两个类，这两个类封装核心业务，有相同的方法 `核心业务1` 我们想在其前后加入日志跟踪调试。

```java
public class Core1{
    public String 核心业务1(){
    		......
	}
    public String 核心业务2(){
    		......
	}
}
```

```java
public class Core2{
    public String 核心业务1(){
    		......
	}
    public String 核心业务3(){
    		......
	}
}
```

创建一个封装了日志功能的类，使用@Aspect注解 表示这是一个切面类

```java
@Aspect
public class UserAspect {
	
	//匹配所有ServiceImpl包下面的所有类的名为核心业务1的方法，以此为切入点
	@Pointcut("execution(* com.ctc.ServiceImpl.*.核心业务1(..))")
	public void addLog(){}  //将切入点的advice命名为addLog
	
	
    @Before("addLog()")//通过addLog()找到切入点，在其之前织入代码
    public void beforeLog(){
        //daima
    }
	
    @After("addLog()")
    public void afterLog(){
        //daima
    }
```



#### AOP源码

## Spring中Bean的作用域及线程安全

在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .

![img](框架.assets\640.png)

默认单例模式也是最常用的模式。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。

**Spring中Bean不是线程安全的**

单例模式下多线程同时执行一个Bean中的方法且修改了内容，线程不安全。

8过，在java web系统中，很少在spring bean中放实例变量，一般是多个组件相互调用，最终访问数据库。造成多线程并发访问数据库。

## Spring中Bean的生命周期

#### 1.Bean生命周期

好了，了解了ioc和相互依赖问题之后，那么我们再来讨论对象的生命周期以及如果是让你来设计一个IOC容器，会怎么设计。

作为框架，就如同复杂算法一样（如红黑树的平衡插入和平衡删除），需要将各种可能的case和需求都考虑进去，Bean的生命周期同样如此，并非简单的new一个对象，除此，还需要考虑对一个对象创建前的增强和特殊需求，以及临终前的额外动作；为了解决循环依赖问题，bean对象的创建并非一蹴而就，需要将对象创建分成创建对象、设置属性等操作。

![img](框架.assets\v2-5137fbc40dc0028787214b248ce2168c_720w.jpg)

Bean生命周期

**a.实例化Bean**

容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。 

- 对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。 
- 对于ApplicationContext容器，当容器启动结束后，便实例化所有的bean。 

实例化对象被包装在BeanWrapper对象中（可以认为是Bean的原生态），BeanWrapper提供了设置对象属性的接口，避免了使用反射机制设置属性。

这里提到了4个组件：**BeanFacotry\ApplicationContext\BeanDefinition\BeanWrapper**

**b.设置对象属性（依赖注入）**

实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。 

紧接着，Spring根据BeanDefinition中的信息进行依赖注入。 

并且通过BeanWrapper提供的设置属性的接口完成依赖注入。

**c.注入Aware接口(给bean增加某种能力，申明是某种特殊的bean)**

Aware接口用于增强Bean能力

容器需检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。

常见的Aware接口有：**BeanNameAware\BeanFactoryAware\ApplicationContextAware**

至此，一个对象已经被正确构造。

**d.1.BeanPostProcessor(自定义处理，满足用户需求)**

经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过**BeanPostProcessor**接口实现。 

该接口提供了两个函数：

- **postProcessBeforeInitialzation**( Object bean, String beanName ) 

当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会先于InitialzationBean执行，因此称为前置处理。 所有Aware接口的注入就是在这一步完成的。

- **postProcessAfterInitialzation**( Object bean, String beanName ) 

当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会在InitialzationBean完成后执行，因此称为后置处理。

组件：BeanPostProcessor

**d.2.InitializingBean与init-method**

当BeanPostProcessor的前置处理完成后就会进入本阶段。 

InitializingBean接口只有一个函数：

- **afterPropertiesSet**()

这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 

若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet函数。

当然，Spring为了降低对客户代码的侵入性，给bean的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。

**e.DisposableBean和destroy-method**

和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。

#### 2.关于Aware接口（Bean能力声明，是某种特殊的bean）

扩展点：

BeanNameAware

BeanFactoryAware

ApplicationContextAware

#### 3.依赖注入的几种方式

一般而言，依赖注入可以分为3种方式。

- **构造器注入。**
- **setter注入。**
- **接口注入。**

**构造器注入**

　　构造器注入依赖于构造方法实现，而构造方法可以是有参数的或者是无参数的。在大部分的情况下，我们都是通过类的构造方法来创建类对象，Spring也可以采用反射的方式，通过使用构造方法来完成注入，这就是构造器注入的原理

```java
public class Role { 
 private Long id;    
 private String roleName;    
 private String note;     
 public Role(String roleName, String note) {        
 this.roleName = roleName;        
 this.note = note;    
    }    
 /******** setter and getter *******/}
```

这个时候是没有办法利用无参数的构造方法去创建对象的，为了使Spring能够正确创建这个对象，可以像代码清单那样去做。

```xml
<bean id="role1" class="com.ssm.chapter9.pojo.Role">    
    <constructor-arg index="0" value="总经理"/>    
    <constructor-arg index="1" value="公司管理者"/>
</bean>
```

 constructorarg元素用于定义类构造方法的参数，其中index用于定义参数的位置，而value则是设置值，通过这样的定义Spring便知道使用Role(String,String)这样的构造方法去创建对象了。这样注入还是比较简单的，但是缺点也很明显，由于这里的参数比较少，所以可读性还是不错的，但是如果参数很多，那么这种构造方法就比较复杂了，这个时候应该考虑setter注入

**使用setter注入**

setter注入是容器中最主流的注入方式，它利用JavaBean规范所定义的setter方法来完成注入，灵活且可读性高。它消除了使用构造器注入时出现多个参数的可能性，首先可以把构造方法声明为无参数的，然后使用setter注入为其设置对应的值，其实也是通过Java反射技术得以现实的。这里假设先在代码清单中为Role类加入一个没有参数的构造方法，然后做代码清单的配置。

```text
<bean id="role2" class="com.ssm.chapter9.pojo.Role">   
    <property name="roleName" value="高级工程师"/>    
    <property name="note" value="重要人员"/>
</bean
```

这样Spring就会通过反射调用没有参数的构造方法生成对象，同时通过反射对应的setter注入配置的值了。这种方式是Spring最为主要的方式，在实际工作中使用广泛。

**接口注入**

　　有些时候资源并非来自于自身系统，而是来自于外界，比如数据库连接资源完全可以在Tomcat下配置，然后通过JNDI的形式去获取它，这样数据库连接资源是属于开发工程外的资源，这个时候我们可以采用接口注入的形式来获取它

#### 4.实现一个容器需要哪些组件

思考点：

- Bean的创建和销毁过程，创建增强点，销毁临终动作。
- Bean循环依赖如何解决；

基于以上分析，我们知道一个IOC容器需包含以下组件：

- BeanDefinition
- BeanWrapper
- BeanFacotry
- Aware
- BeanNameAware
- BeanFactoryAware
- BeanPostProcess
- InitialzatingBean
- DisposableBean

具体组件需提供哪些功能可参考Spring beans，可试着自己写一个IOC容器，然后对比Spring实现。

## Spring中的事务

### 声明式事务管理

编程式事务每次实现都要单独实现，但业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过**注解@Transactional**的方式，便可以将事务规则应用到业务逻辑中。

对于纯JDBC操作数据库，想要用到事务，可以按照以下步骤进行：

1. 获取连接 Connection con = DriverManager.getConnection()

2. 开启事务con.setAutoCommit(true/false);

3. 执行CRUD

4. 提交事务/回滚事务 con.commit() / con.rollback();

5. 关闭连接 conn.close()；

   使用Spring的事务管理功能后，我们可以不再写步骤 2 和 4 的代码，而是由Spirng 自动完成。

**声明式事务管理建立在AOP之上，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。**

### 事务的传播机制

事务的传播性一般用在事务嵌套的场景，比如一个事务方法里面调用了另外一个事务方法，那么两个方法是各自作为独立的方法提交还是内层的事务合并到外层的事务一起提交，这就是需要事务传播机制的配置来确定怎么样执行。

```java
@Transaction(propagation=PROPAGATION_REQUIRED)
public void methodA{
    //do something
    methodB();
    //do something
}
@Transaction(propagation=PROPAGATION_REQUIRED)
public void methodB{
    //do something
}
```

- PROPAGATION_REQUIRED
  Spring默认的传播机制，能满足绝大部分业务需求，如果外层有事务，则当前事务加入到外层事务，一块提交，一块回滚。如果外层没有事务，新建一个事务执行

  开启一个事务

  执行methodA中代码；

  执行methodB中代码；

  提交或回滚事务。

  

- PROPAGATION_SUPPORT
  如果外层有事务，则加入外层事务，如果外层没有事务，则直接使用非事务方式执行。完全依赖外层的事务

- PROPAGATION_REQUES_NEW
  该事务传播机制是每次都会新开启一个事务，同时把外层事务挂起，当当前事务执行完毕，恢复上层事务的执行。如果外层没有事务，执行当前新开启的事务即可

  开启一个事务

  执行methodA中代码；

  开启一个事务

  执行methodB中代码；

  提交或回滚事务。

  执行methodA中代码；

  提交或回滚事务。

······

## Spring中使用的设计模式

**工厂模式**





**单例模式** 

Spring依赖注入Bean实例默认是单例的。



**代理模式**

AOP底层，就是动态代理模式的实现