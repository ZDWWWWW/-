# 设计模式

## 工厂

### 简单工厂模式

产品抽象类

产品实现类

工厂类：创建产品类实例。

客户端：调用工厂类产生实例，并调用实例的方法进行相应工作。

### 工厂方法模式

产品抽象类

产品实现类

工厂抽象类

工厂实现类

客户端：调用工厂类产生实例，并调用实例的方法进行相应工作。

**一个抽象工厂对应一个抽象产品，一个具体工厂对应一个具体产品。**

**优点：**降低了耦合，增加新的产品实现时，只需添加一套对应的工厂实现和产品实现就可以了。在简单工厂中需要修改工厂类，需要修改源代码。

### 抽象工厂模式

https://www.runoob.com/design-pattern/abstract-factory-pattern.html

**抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。**

产品抽象类：面条、包子

产品实现类：兰州拉面、泡面、叉烧包、豆沙包

工厂抽象类：面食厂（方法1：生产面条 方法2：生产包子）

工厂实现类：面食店1（方法1：兰州拉面 方法2：叉烧包）面食店2（方法1：泡面 方法2：豆沙包）

增加新类别的火锅，增加工厂接口中方法3：生产火锅





## 单例模式

**特点：**

- 类构造器私有
- 持有自己类型的属性
- 对外提供获取实例的静态方法

### 懒汉式

```java
public class Singleton {
    private static Singleton instance;  //单例对象    
    
    private Singleton() {}  //私有构造函数
    
    public static Singleton getInstance() {  //静态工厂方法
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 饿汉式

```java
public class Singleton {  
    private static Singleton instance = new Singleton();  
    
    private Singleton (){}  
    
    public static Singleton getInstance() {  
    return instance;  
    }  
}
```

比较常用，类加载时就对实例初始化，浪费内存。

### 双重检查锁(double-checked locking, DCL)

```java
public class Singleton {  
    private volatile static Singleton instance;  
    
    private Singleton (){}  
    
    public static Singleton getSingleton() {  
    if (instance == null) {  
        synchronized (Singleton.class) {  
        	if (instance == null) {  
           		instance = new Singleton();  
        	}  
        }  
    }  
    return instance;  
    }  
}
```

锁加到 getSingleton() 前也可以解决问题，但会导致很大的性能开销。

**为什么要进行第二次判断呢？**

如果多个线程**同时**通过了第一次检查，并且其中一个线程获得锁后首先实例化了对象。释放锁后，如果不进行二次判断，其他线程获取锁还是会创建对象，产生错误。

**为什么对实例加volatile呢？**

初始化对象分为以下三个步骤

1. 分配内存空间
2. 初始化对象（new）
3. 将对象指向刚分配的内存空间

但是有些编译器为了性能的原因，可能会将第二步和第三步进行重排序

例如，线程 A 执行了`分配内存空间`和 `将对象指向刚分配的内存空间`，此时 B 调用 getSingleton() 后发现 instance 不为空，因此返回 instance，从而返回一个未初始化的对象。