# Java基础



# JVM

## 内存区域

1. Java文件经过编译后变成 .class 字节码文件
2. 字节码文件通过类加载器被搬运到 JVM 虚拟机的方法区中

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区

### 程序计数器

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**

另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**

**从上面的介绍中我们知道程序计数器主要有两个作用：**

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

**注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

### Java 虚拟机栈

**与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。**

**局部变量表主要存放了编译器可知的8种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。**

- **StackOverFlowError：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。

### 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

### 堆

Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

### 方法区

用于存储已被虚拟机加载的类信息、常量（final）、静态变量（static）、即时编译器编译后的代码等数据。

**永久代和元空间都是方法区的具体实现**

#### 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?

整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

## 垃圾回收

### 对象存活判断

**引用计数**：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，***\*无法解决对象相互循环引用\****的问题。

**可达性分析**（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。

### 辣鸡收集算法

  **标记-清除**（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。

它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，**空间碎片太多**可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![wpsA73E.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160624174234266-1575111287.png)

 

**复制**（Copying）算法，它将可用内存按容量划分为两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价持续复制长生存期的对象则导致效率降低。

实践中会将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间 ，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。**HotSpot虚拟机默认Eden和Survivor的大小比例是 8:1:1**，也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% )，只有10% 的内存会被“浪费”。

​								 ![wps9D31.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160624174237703-328169343.png)

根据老年代的特点，有人提出了另外一种“**标记-整理**”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

![wps3952.tmp](https://images2015.cnblogs.com/blog/331425/201606/331425-20160624174239219-1187241876.png)

“**分代收集**”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

### 辣鸡收集器

![img](Java基础及JVM.assets/11e9dcd0f1ee4f25836e6f1c47104c51-new-image69e1c56a-1d40-493a-9901-6efc647a01f3.png)

新生代算法均为复制算法，老年代算法除了CMS均为标记整理算法。

到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old 

从jdk9开始，G1收集器成为默认的垃圾收集器

#### **CMS工作原理**

CMS收集器是基于“**标记-清除**”算法实现的

整个过程分为4个步骤，包括：

**初始标记（CMS initial mark）**

会Stop The World停止工作线程,标记GC Roots(局部变量和类的静态变量)引用的对象。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，

**并发标记（CMS concurrent mark）**

并发进行，系统一边工作，一边进行垃圾回收，对系统的所有对象进行GC Root追踪，看有没有最终被GC Root的对象引用，这个过程很耗时。但是不影响系统的工作，系统工作期间会继续有对象进入老年代，这些对象有可能变成垃圾或被引用，在下一个阶段进行处理。

**重新标记（CMS remark）**

会Stop The World，为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。速度很快。

**并发清除（CMS concurrent sweep）**

这个阶段很耗时，和系统并发运行，不影响系统工作。清理掉被标记的垃圾对象，并进行对象移动整理，减少内存碎片。

## 类加载

### 类加载过程

![image-20200513113655154](Java基础及JVM.assets/image-20200513113655154.png)

#### 加载

1. 通过类的.class文件获取二进制字节流
2. 将其转化为**方法区**的运行时数据结构
3. 内存中生成**class类对象**（非实例对象）

相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

通过使用不同的类加载器，可以从不同来源加载类的二进制数据，二进制数据通常有如下几种来源：

（1）从本地系统中直接加载

（2）通过网络下载.class文件

（3）从zip，jar等归档文件中加载.class文件

（4）从专用数据库中提取.class文件

（5）将java源文件动态编译为.class文件

#### 验证

确保class文件中字节流信息符合虚拟机要求。

#### 准备

当完成字节码文件的校验之后，JVM 便会开始为**类变量（static变量）**分配内存（方法区）并初始化。**这里不会为实例变量分配初始化**，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

**初始化时，类变量初始值是数据类型的零值**

**若类变量同时被final修饰，初始化时，则赋予用户想要的值。**

#### 解析

解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。

#### 初始化

到了初始化阶段，才开始执行Java程序代码（字节码）

**为类变量赋予正确的初始值**



### 类加载器

对任意类，需要类本身和加载它的类加载器一同确立在Java虚拟机中的唯一性

**当两个类源于同一Class文件，若类加载器相同，两类相等。类加载器不相同，两类不相等**



JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由C++实现，负责加载 `%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。
3. **AppClassLoader(应用程序类加载器)** :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。开发者可以直接使用这个类加载器，若没有定义过自己的类加载器，这就是默认的底层类加载器。

除此以外，还可以定义自己的类加载器

### 双亲委派模型

每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，它是不会先自己去尝试加载的，而是委派给父类去完成，当父类加载器为null时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。

在`BootstrapClassLoader`中的加载过程：

1. 在`BootstrapClassLoader`指定路径下查找并加载该类

2. 若`BootstrapClassLoader`不能找到该类，则让子类加载

3. 若最底层加载器也无法找到该类，则抛出ClassNotFundException异常

   

**优点**：**避免重复加载 + 避免核心类篡改**